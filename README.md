# -
算法
引出：
问题描述:给出一个序列a1,a2,a3,a4,a5,a6,a7….an,求它的一个子序列（设为s1,s2,…sn），使得这个子序列满足这样的性质，s1<s2<s3<…<sn并且这个子序列的长度最长。输出这个最长的长度。（为了简化该类问题，我们将诸如最长下降子序列及最长不上升子序列等问题都看成同一个问题，其实仔细思考就会发现，这其实只是<符号定义上的问题，并不影响问题的实质）
例如有一个序列:1  7  3  5  9  4  8,它的最长上升子序列就是 1 3 4 8 长度为4.

分析：
这题目是经典的DP题目，也可叫作最长上升子序列或者 最长不下降子序列。

解法：
时间复杂度:O(n^2):
依次遍历整个序列，每一次求出从第一个数到当前这个数的最长上升子序列，直至遍历到最后一个数字为止，然后再取dp数组里最大的那个即为整个序列的最长上升子序列。我们用dp[i]来存放序列1-i的最长上升子序列的长度，那么dp[i]=max(dp[j])+1,(j∈[1, i-1]); 显然dp[1]=1,我们从i=2开始遍历后面的元素即可。

个人理解：从低到高计算出到当前下标位置i的最长子序列，然后计算下一位j是否比a[i]大，是的话下标j处的最长子序列即为i处最长子序列加1

int LIS(int arr[1000], int n)
{
	for(int i=1; i<=n; ++i)
		dp[i] = 0;
	int ans;
	dp[1] = 1;
	for(int i=2; i<=n; ++i)
	{
		ans = dp[i];
		for(int j=1; j<i; ++j)
		{
			if(arr[i]>arr[j] && dp[j]>ans)
				ans = dp[j];
		}
		dp[i] = ans+1;
	}
	ans = 0;
	for(int i=1; i<=n; ++i)
	{
		if(dp[i] > ans)
			ans = dp[i];
	}
	return ans;
}
